---
layout: post
title: "[译文]Ruby中的值对象"
description: ""
category: ""
tags: [Ruby, Value Object ]
---
{% include JB/setup %}

这篇文章解释了值对象的概念。它首先定义并演示了值对象，然后阐述了构建有效值对象的规则以及违反的概念的后果。最后，展示了几种用Ruby实现值对象的方法。
虽然这些例子都是用Ruby实现的，但是也同样适用其他语言。

## 什么是值对象?
在[P of EAA](http://martinfowler.com/bliki/ValueObject.html)定义如下:

> 决定两个值对象相等的是它们内部的fields，而不是它们的identity

这就意味着拥有相等内部fields的值对象，它们必然相等。所有fields的值相等充分能够证明值对象的相等性。

最简单的例子就是原始对象－`Symbol`, `String`, `Integer`, `TrueClass(true)`, `FalseClass(false)`, `NilClass(nil)`, `Range`, `Regexp` 等等.
每个对象的值决定了它们的相等性。比如，在你的程序中任何地方出现 `1.0`, 它必然等于 `1.0`因为它们相等。

    var1 = :symbol
    var2 = :symbol
    var1 == var2  # => true
 
    var1 = 'string'
    var2 = 'string'
    var1 == var2  # => true
     
    var1 = 1.0
    var2 = 1.0
    var1 == var2  # => true
     
    var1 = true
    var2 = true
    var1 == var2  # => true
     
    var1 = nil
    var2 = nil
    var1 == var2  # => true
     
    var1 = /reg/
    var2 = /reg/
    var1 == var2  # => true
     
    var1 = 1..2
    var2 = 1..2
    var1 == var2  # => true
     
    var1 == [1, 2, 3]
    var2 == [1, 2, 3]
    var1 == var2  # => true
     
    var1 == { key: 'value'}
    var2 == { key: 'value'}
    var1 == var2  # => true

上面是一些只有一个filed的值对象例子

值对象也能由多个field组成。比如标准库中的`IPAddr`类有`@addr`, `@mask_addr` 和 `@family` 三个fields. `@addr`和`@mask_addr`定义了IP地址的值，`@family`决定了它是IPv4还是IPv6. 拥有相等filed值的`IPAddr`对象是相等的。

    require 'ipaddr'
     
    ipaddr1 = IPAddr.new "192.168.2.0/24"
    ipaddr2 = IPAddr.new "192.168.2.0/255.255.255.0"
     
    ipaddr1.inspect
    # => "#<IPAddr: IPv4:192.168.2.0/255.255.255.0>"
     
    ipaddr2.inspect
    #=> "#<IPAddr: IPv4:192.168.2.0/255.255.255.0>"
     
    ipaddr1 == ipaddr2 # => true

同样，money, GPS data, tracking data, date range这些都可以被用作值对象来处理。

上面的例子展示了值对象的定义－ 决定值对象相等的是他们的内部fields而不是identity。

为了确保在程序中有相同fields的值对象相等,在构造值对象时应该遵守一个隐式的规则

## 构造值对象的规则

保证值对象在声明周期中相等的规则是:**值对象的属性从被实例化到存在最后的状态保持不变**. "也就是说被创建的两个值对象相等，就必须保持相等".
所以，值对象应该有不可变的接口
